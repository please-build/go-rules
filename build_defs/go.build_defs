""" Rules to build Go code.

Go has a strong built-in concept of packages so it's probably a good idea to match Please
rules to Go packages.
"""
def go_toolchain(name:str, url:str|dict = '', version:str = '', hashes:list = [], visibility:list = ["PUBLIC"],
                 architectures:list=[], strip_srcs:bool=False, tags:list=None, install_std=None):
    """
    Downloads Go and exposes :<name>|go and :<name>|gofmt as entry points. To use this rule add the
    following to your .plzconfig:

    [go]
    GoTool = //.../<name>|go

    Args:
      name (str): Name of the rule.
      url (str | dict): The URL used to download Go. Can be a single string or a dictionary mapping
                        GOOS-GOARCH to URLs i.e. linux-amd64: 'https://...'. Either provide url or version, but not both.
      version (str): The version of Go to download. Go will be downloaded from https://golang.org/dl/...
                     and the rule will use the current platforms GOOS and GOARCH setting. Either provide url or version,
                     but not both.
      hashes (list): A list of possible hashes for the downloaded archive. Optional.
      visibility (list): Visibility specification. Defaults to public.
      architectures (list): Any additional architectures to install in go architecture format e.g. linux_amd64. This
                            rule will automatically install the arch provided through --arch. This is only useful if you
                            want to manually cross-compile parts of the repo but not others.
      strip_srcs (bool): Whether to strip sources from the SDK which can reduce the size of the cached artifacts and
                         improve performance, especially for remote execution.
      tags (bool): Build tags to pass when installing the standard library.
      install_std (bool): Whether we should install the standard library. This is required for go 1.20+. If not set,
                          Please will do whatever is appropriate based on the Go version.
    """
    if url and version:
        fail("Either version or url should be provided but not both")

    if version:
        sdk_url = f'https://golang.org/dl/go{version}.{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}.tar.gz'
    else:
        sdk_url = url if isinstance(url, str) else url[f'{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}']

    download = remote_file(
        name = name,
        _tag = 'download',
        url = sdk_url,
        hashes = hashes,
    )

    if semver_check(version, ">= 1.20.0") and install_std is None:
        install_std = True

    return _go_toolchain(
        name = name,
        srcs = [download],
        copy_cmd = 'tar -xf $SRCS && mv go $OUT',
        visibility = visibility,
        architectures = architectures,
        strip_srcs = strip_srcs,
        tags = tags,
        install_std = install_std,
    )


def _go_toolchain(name:str, srcs:list, copy_cmd:str, visibility:list, architectures:list, tags:list, strip_srcs:bool=False, install_std:bool=None):
    cmd = f'export GODEBUG="installgoroot=all" && {copy_cmd} && chmod +x $OUT/bin/*; rm -rf $OUT/test'
    # If we're targeting another platform, build the std lib for that. We can't use CONFIG.OS as this is always set to
    # the host OS for tools.
    if CONFIG.TARGET_OS != CONFIG.HOSTOS or CONFIG.TARGET_ARCH != CONFIG.HOSTARCH:
        architectures += [f'{CONFIG.TARGET_OS}_{CONFIG.TARGET_ARCH}']

    if architectures and CONFIG.GO.CGO_ENABLED == "1":
        flags = " ".join(CONFIG.GO.C_FLAGS)
        cmd += f" && export CGO_ENABLED={CONFIG.GO.CGO_ENABLED} && export CFLAGS=\"{flags}\" && export CC=$TOOLS_CC"

    tag_flag = (' -tags ' + ','.join(tags)) if tags else ''
    for arch in architectures:
        goos, _, goarch = arch.partition("_")
        cmd += f' && (export GOOS={goos} && export GOARCH={goarch} && $OUT/bin/go install{tag_flag} --trimpath std)'

    if install_std:
        cmd += f" && $OUT/bin/go install{tag_flag} --trimpath std"
    if strip_srcs:
        trim_toolchain = "mv $OUT/src src && mkdir $OUT/src && mv src/unsafe $OUT/src/unsafe"
        cmd = f"{cmd} && {trim_toolchain}"

    #TODO(jpoole): Add the option to compile these with -race for the race detector as well. This need to be plumbed
    # through to the go_library rules as well though.
    return build_rule(
        name = name,
        srcs = srcs,
        cmd = cmd,
        outs = [name],
        entry_points = {
            'go': f'{name}/bin/go',
            'gofmt': f'{name}/bin/gofmt',
        },
        tools = {
          "CC": [CONFIG.GO.CC_TOOL],
        } if CONFIG.GO.CGO_ENABLED == "1" else {},
        binary = True,
        visibility = visibility,
        building_description = "Installing...",
    )


def go_system_toolchain(name:str, cmd:str="go", architectures:list=[], tags:list=None, install_std:bool=True, visibility:list = ["PUBLIC"]):
    """Defines a Go toolchain that's installed on the local system.

    This is similar to using simply `go` as your gotool, but from 1.20 onwards it's necessary in order to
    compile the standard library.

    Args:
      name: Name of the rule
      cmd: Command to run to locate it (usually just 'go')
      architectures: Architectures to build the standard library for
      install_std: Whether we should build the standard library. On by default.
      tags: Build tags to pass when installing the standard library.
      visibility: Visibility of this rule
    """
    return _go_toolchain(
        name = name,
        srcs = [],
        copy_cmd = f'cp -r `{cmd} env GOROOT` $OUT',
        visibility = visibility,
        architectures = architectures,
        strip_srcs = False,
        tags = tags,
        install_std = install_std,
    )


def go_stdlib(name:str, tags:list=[], visibility:list=["PUBLIC"]):
    """Defines compilation of the Go standard library.

    This is idiomatically configured in //third_party/go and set as the gostdlib config value for the Go plugin.

    Args:
      name: Name of the rule
      tags: Go build tags (e.g. 'osusergo' or 'netgo' are relevant to the stdlib)
      visibility: Visibility of this rule
    """
    # Need to write package info for the stdlib as well. This requires the source to be present.
    srcs = build_rule(
        name = name,
        tag = 'srcs',
        outs = [name + '/src'],
        cmd = 'cp -r "`$TOOL env GOROOT`/src" "$OUT"',
        tools = [CONFIG.GO.GO_TOOL],
    )

    flags = ''
    suffix = ''
    if tags:
        flags = ' -tags ' + ','.join(tags)
    if CONFIG.GO.BUILDMODE:
        if CONFIG.GO.BUILDMODE in ['plugin', 'shared', 'c-shared']:
            # We don't actually build the stdlib with -buildmode plugin, we just need -buildmode shared,
            # but it adds an extra _dynlink on the end automatically.
            flags += f' -buildmode shared -installsuffix {CONFIG.GO.BUILDMODE}'
            suffix = f'_{CONFIG.GO.BUILDMODE}_dynlink'
        else:
            flags += f' -buildmode {CONFIG.GO.BUILDMODE} -installsuffix {CONFIG.GO.BUILDMODE}'
            suffix = f'_{CONFIG.GO.BUILDMODE}'
    if CONFIG.GO.RACE:
        suffix += '_race'
        flags += ' -race'
    # We have to take some care to compile this in our working directory and not try to install
    # it to the existing GOROOT, which might not be writable.
    cmds = [
        'GOROOT="`$TOOLS_GO env GOROOT`"',
        'cp -r "$GOROOT/src" "$GOROOT/pkg" .',
        f"GOROOT=$TMP_DIR $TOOLS_GO install{flags} --trimpath std",
        "rm -rf pkg/tool pkg/include",
        "mv pkg $OUTS_PKG",
        f'find "$OUTS_PKG" -name "*.a" | sed -e "s=^$OUTS_PKG/{CONFIG.OS}_{CONFIG.ARCH}{suffix}/==" | sed -e s="\.a$"== | xargs -I{{}} echo "packagefile {{}}="$PKG_DIR/$OUTS_PKG"/{CONFIG.OS}_{CONFIG.ARCH}{suffix}/{{}}.a" | sort -u > $OUTS_IC',
        '$TOOLS_PLZGO m -m "" -s "$SRCS" --importconfig "$OUTS_IC" > $OUTS_PKG_INFO',
    ]
    return genrule(
        name = name,
        srcs = {"srcs": [srcs]},
        outs = {
            "pkg": [name + "/pkg"],
            "ic": [f"{name}/{name}.importconfig"],
            "pkg_info": [name + "/pkg_info.json"],
        },
        cmd = cmds,
        tools = {
            "go": [CONFIG.GO.GO_TOOL],
            "plzgo": [CONFIG.GO.PLEASE_GO_TOOL],
        },
        env = {
            "GOOS": CONFIG.OS,
            "GOARCH": CONFIG.ARCH,
            "GODEBUG": "installgoroot=all",
            "CGO_ENABLED": CONFIG.GO.CGO_ENABLED,
        },
        labels = ["go_pkg_info", "go_stdlib", "go"],
        output_is_complete = True,
        visibility = visibility,
    )


def _pkg_sources(name: str, deps: list, test_only:bool):
    """
    This rule generates a list of go srcs for any rule in the deps list that is local to this package.

    This is how we avoid transitively depending on all sources for a target in order to compile non-external tests.
    Without this, we'd have to transitively pull in all third party sources for the rule which is very expensive,
    especially for remote execution.
    """
    package_prefix = canonicalise(":all").removesuffix("all")
    return filegroup(
       name = name,
       tag = "pkg_srcs",
       exported_deps = [dep for dep in deps if canonicalise(dep).startswith(package_prefix)],
       requires = ["go_src"],
       test_only = test_only,
   )

def go_library(name:str, srcs:list, resources:list=[], asm_srcs:list=None, hdrs:list=None, deps:list=[],
               visibility:list=None, test_only:bool&testonly=False, complete:bool=True,
               _needs_transitive_deps=False, _all_srcs=False, cover:bool=True,
               filter_srcs:bool=True, _link_private:bool=False, _link_extra:bool=True, _abi:str=None,
               _generate_import_config:bool=True, _generate_pkg_info:bool=True,
               import_path:str='', labels:list=[], package:str=None):
    """Generates a Go library which can be reused by other rules.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      resources (list): Files to embed in the library using //go:embed directives.
      asm_srcs (list): Source files to assemble with `go tool assemble`.
      hdrs (list): Header files needed for assembly. Has no effect if asm_srcs is not given.
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If True, is only visible to test rules.
      complete (bool): Indicates whether the library is complete or not (ie. buildable with
                       `go tool build -complete`). In nearly all cases this is True (the main
                       exception being for cgo).
      cover (bool): Indicates whether this library should be considered for coverage annotations.
                    Libraries are only annotated when using `plz cover` (or `plz build -c cover`),
                    but if this is false they never will be. Can be useful for e.g. third-party
                    code that you never want to be instrumented.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      import_path (str): If set, this will override the import path of the generated go package.
      package (str): The package as it would appear at the top of the go source files. Defaults
                     to name.
    """
    assert srcs, "Cannot provide an empty srcs list to go_library"
    cover = cover and CONFIG.BUILD_CONFIG == "cover"
    package = package or name
    out = package + '.a'
    link_labels = []
    src_labels = []
    private = out.startswith('_')
    package_path = _get_import_path(package, import_path)

    # We could just depend on go_src for all our deps but that would mean bringing in srcs for targets outside this
    # package like third party sources which is especially slow on systems with slow syscall performance (macOS)
    if _all_srcs:
        deps += [_pkg_sources(name, deps, test_only)]
    if CONFIG.GO.STDLIB:
        deps += _stdlib()

    if _generate_import_config:
        import_cfg = build_rule(
            name=name,
            tag='import_config',
            cmd = _write_import_config_cmd(package, import_path),
            outs = [f'{package}.importconfig'],
            visibility=visibility,
            test_only=test_only,
            labels=labels,
        )
        exported_deps = [import_cfg]
    else:
        exported_deps = []

    if cover and not CONFIG.GO.COVERAGEREDESIGN:
        cover_vars = build_rule(
            name = name,
            tag = "cover_vars",
            srcs = srcs,
            cmd = f"$TOOL covervars --import_path {package_path} $($TOOL filter $SRCS) > $OUT",
            tools = [CONFIG.GO.PLEASE_GO_TOOL],
            outs = [f"{name}.cover_vars"],
            visibility = visibility,
            test_only = test_only,
        )
        deps += [cover_vars]
    if resources:
        embedcfg = build_rule(
            name = name,
            tag = 'embedcfg',
            cmd = '$TOOL embed $PKG_DIR/*.go > $OUT' if _all_srcs else '$TOOL embed $SRCS_GO > $OUT',
            srcs = {
                'go': srcs,
                'res': resources,
            },
            deps = deps if _all_srcs else None,
            outs = [f'{package}.embedcfg'],
            requires = ['go_src'],
            tools = [CONFIG.GO.PLEASE_GO_TOOL],
            test_only = test_only,
            labels = labels,
        )
    else:
        embedcfg = None

    if _link_private or not private:
        src_labels = ['link:plz-out/go/src/${PKG}', 'go_src']
        if not private:
            link_labels = ['link:plz-out/go/pkg/${GOOS}_${GOARCH}/${PKG}']
        libname = out[:-2] if len(out) > 2 else out
        if libname != basename(package_name()) and _link_extra:
            # Libraries that are in a directory not of their own name will need the sources in
            # a subdirectory for go to be able to transparently import them.
            src_labels += [f'link:plz-out/go/src/$PKG/{libname}']
    if asm_srcs:
        abi_rule = build_rule(
            name = name,
            tag = 'abi',
            srcs = {
                'asm': asm_srcs,
                'hdrs': hdrs,
            },
            outs = [name + '.abi'],
            building_description = 'Creating ABI...',
            cmd = f'eval `"$TOOL" env` && "$TOOL" tool asm -trimpath "$TMP_DIR" -I $GOROOT/pkg/include -D GOOS_{CONFIG.OS} -D GOARCH_{CONFIG.ARCH} -gensymabis -o "$OUT" $SRCS_ASM',
            env= {
                "GOOS": CONFIG.OS,
                "GOARCH": CONFIG.ARCH,
            },
            tools=[CONFIG.GO.GO_TOOL],
            test_only = test_only,
            labels=labels,
        )
        lib_rule = go_library(
            name = f'_{name}#lib',
            srcs = srcs,
            resources = resources,
            deps = deps,
            test_only = test_only,
            complete = False,
            cover = cover,
            _abi = abi_rule,
            _needs_transitive_deps = _needs_transitive_deps,
            _all_srcs = _all_srcs,
            _generate_import_config=False,
            labels=labels,
            import_path=package_path,
        )
        asm_rule = build_rule(
            name = name,
            tag = 'asm',
            srcs = {
                'asm': asm_srcs,
                'hdrs': hdrs,
                'hdr': [lib_rule + '|h'],
            },
            outs = [name + '.o'],
            building_description = 'Assembling...',
            cmd = f'eval `"$TOOL" env` && "$TOOL" tool asm -trimpath "$TMP_DIR" -I ${GOROOT}/pkg/include -D GOOS={CONFIG.OS} -D GOARCH_{CONFIG.ARCH} -p {package_path} -o "$OUT" $SRCS_ASM',
            env= {
                "GOOS": CONFIG.OS,
                "GOARCH": CONFIG.ARCH,
            },
            tools=[CONFIG.GO.GO_TOOL],
            test_only = test_only,
            labels=labels,
        )
        provides = {'go': ':' + name, 'go_src': lib_rule}
        if cover and not CONFIG.GO.COVERAGEREDESIGN:
            provides['cover_vars'] = cover_vars
        return build_rule(
            name = name,
            srcs = {
                'lib': [lib_rule + '|o'],
                'asm': [asm_rule],
            },
            outs=[out],
            tools=[CONFIG.GO.GO_TOOL],
            cmd = 'cp $SRCS_LIB "$OUT" && chmod +w "$OUT" && "$TOOL" tool pack r "$OUT" $SRCS_ASM',
            visibility = visibility,
            building_description = 'Packing...',
            requires = ['go'],
            labels = labels+link_labels,
            provides = provides,
            test_only = test_only,
            exported_deps = exported_deps,
            deps = deps,
        )

    # go_test and cgo_library need access to the sources as well.
    src_rule = filegroup(
        name = name,
        tag = 'srcs',
        srcs=srcs,
        exported_deps=deps,
        visibility=visibility,
        requires=['go'],
        labels = labels + src_labels,
        test_only=test_only,
    )

    # Package info rule for the Go packages driver
    if _generate_pkg_info:
        deps += [_go_pkg_info(
            name = name,
            srcs = srcs + resources,
            import_path = import_path,
            package = package,
            complete = complete,
            test_only = test_only,
        )]

    tools = { 'go': [CONFIG.GO.GO_TOOL] }
    if filter_srcs or cover:
        tools['please_go'] = [CONFIG.GO.PLEASE_GO_TOOL]

    srcs = {
        'go': srcs,
        'embed': [embedcfg],
        'res': resources,
        'abi': [_abi],
    }
    if _abi:
        outs = {
            'o': [out],
            'h': [name + '.h'],
        }
    else:
        outs = [out]

    provides = {'go': ':' + name, 'go_src': src_rule}
    if cover and not CONFIG.GO.COVERAGEREDESIGN:
        provides['cover_vars'] = cover_vars
    return build_rule(
        name = name,
        srcs = srcs,
        deps = deps,
        internal_deps = [src_rule],
        outs = outs,
        cmd = _go_library_cmds(import_path=package_path, complete=complete, all_srcs=_all_srcs, cover=cover, filter_srcs=filter_srcs, abi=_abi, embedcfg=embedcfg),
        visibility = visibility,
        building_description = "Compiling...",
        requires = ['go'],
        provides = provides,
        labels = labels+link_labels + [f"go_package:{package_path}"] if _generate_import_config else [],
        test_only = test_only,
        tools = tools,
        needs_transitive_deps = _needs_transitive_deps,
        exported_deps = exported_deps,
    )

def _generate_pkg_import_cfg_cmd(out, pkg_location, handle_basename_eq_dirname=False):
    """
    Generates a .importconfig file for all .a files within a go pkg directory for use with
    `go tool {compile/link} -importcfg`. This is used to generate a config file for the go SDK and third party
    dependencies.
    """
    pkg_location = f'{pkg_location}/pkg/{CONFIG.OS}_{CONFIG.ARCH}'
    find_archives = f'find {pkg_location} -name "*.a"'
    remove_pkg_location = f'sed -e s=^{pkg_location}/=='
    remove_ext = 'sed -e s="\.a\$"=='

    if handle_basename_eq_dirname:
        format_packagefile_directive = ' '.join([
            'while read -r IMPORT; do',
                'echo "packagefile $IMPORT=' + pkg_location + '/$IMPORT.a";'
                'if [ "$(basename $(dirname $IMPORT))" == "$(basename $IMPORT)" ];',
                    'then echo "packagefile $(dirname $IMPORT)=' + pkg_location + '/$IMPORT.a";',
                'fi;',
            'done',
        ])
    else:
        format_packagefile_directive = 'xargs -I{} echo "packagefile {}=' + pkg_location + '/{}.a"'

    return f'{find_archives} | {remove_pkg_location} | {remove_ext} | {format_packagefile_directive} | sort -u > {out}'
def _aggregate_import_cfg_cmd():
    return 'find . -name "*.importconfig" | xargs -I{} cat {} | sort -u >> importconfig'

def _trim_import_path(pkg):
    parts = pkg.split("/")
    name = parts[-1]
    dir = parts[-2]

    if name == dir:
        return pkg.removesuffix(f'/{name}')
    else:
        return pkg

def _write_import_config_cmd(package, import_path):
    import_path = _get_import_path(package, import_path)
    return f"echo packagefile {import_path}=$PKG_DIR/{package}.a >> $OUT"

def _get_import_path(package="", import_path=""):
    if import_path:
        return import_path

    pkg = package_name()

    if CONFIG.GO.IMPORT_PATH:
        if pkg:
            path = f'{CONFIG.GO.IMPORT_PATH}/{pkg}'
        else:
            path = CONFIG.GO.IMPORT_PATH
    else:
        path = pkg

    if CONFIG.GO.LEGACY_IMPORTS and package and not path.endswith(package):
        return f"{path}/{package}"

    return path

def go_binary(name:str, srcs:list=[], resources:list=None, asm_srcs:list=[], out:str=None, deps:list=[], data:list=None,
              visibility:list=None, labels:list=[], test_only:bool&testonly=False, static:bool=CONFIG.GO.DEFAULT_STATIC,
              filter_srcs:bool=True, definitions:str|list|dict=None, stamp:bool=False):
    """Compiles a Go binary.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files, one of which contains the main function.
      resources (list): Files to embed in the library using //go:embed directives.
      asm_srcs (list): Assembly source files.
      out (str): Name of the output file to create. Defaults to the same as `name`.
      deps (list): Dependencies
      data (list): Runtime dependencies of this rule.
      visibility (list): Visibility specification
      labels (list): Labels for this rule.
      test_only (bool): If True, is only visible to test rules.
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
      stamp (bool): Allows this rule to gain access to information about SCM revision etc
                    via env vars. These can be useful to pass into `definitions`.
    """
    _srcs = srcs or [name + '.go']
    lib = go_library(
        name=f'_{name}#lib',
        srcs=_srcs,
        resources = resources,
        filter_srcs=filter_srcs,
        asm_srcs=asm_srcs,
        deps=deps,
        labels=labels,
        test_only=test_only,
        _link_private = True,
        _link_extra = False,
        _generate_import_config=False,
        import_path="main",
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, split_debug=CONFIG.GO.SPLIT_DEBUG_INFO)
    if CONFIG.GO.STDLIB:
        deps += _stdlib()

    debug_cmd, debug_data, debug_tools = _debug_cmd(
        name=name,
        bin="./$OUT",
        srcs=_srcs,
        deps=deps,
        test_only=test_only,
    )
    out = out or name
    return build_rule(
        name=name,
        srcs=[lib],
        deps=deps,
        data=data,
        debug_data=debug_data,
        outs=[out],
        optional_outs = [out + '.sym'] if CONFIG.GO.SPLIT_DEBUG_INFO else None,
        cmd=cmds,
        debug_cmd=debug_cmd,
        building_description="Linking...",
        needs_transitive_deps=True,
        binary=True,
        output_is_complete=True,
        test_only=test_only,
        tools=tools,
        debug_tools=debug_tools,
        visibility=visibility,
        labels=labels,
        requires=['go'],
        provides={
            'go': lib,
        },
        pre_build=_collect_linker_flags(static, definitions),
        stamp = stamp,
    )

def merge_cgo_obj(name, a_rule, o_rule=None, visibility=None, test_only=False, tag='',
                   linker_flags:list=[], deps=None, exported_deps=None, provides=None, package=None, labels:list=[]):
    """Defines a rule to merge a cgo object into a Go library."""
    if o_rule:
        cmd = 'cp $SRCS_A "$OUT" && chmod +w "$OUT" && "$TOOLS_AR" x $SRCS_O && "$TOOLS_GO" tool pack r "$OUT" *.o'
    else:
        cmd = 'cp $SRCS_A "$OUT" && chmod +w "$OUT" && "$TOOLS_AR" x $PKG_DIR/*#c.a && "$TOOLS_GO" tool pack r "$OUT" *.o'

    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            'a': [a_rule],
            'o': [o_rule] if o_rule else [],
        },
        outs = [(package or name) + '.a'],
        cmd = cmd,
        tools = {
            'go': [CONFIG.GO.GO_TOOL],
            'ar': [CONFIG.GO.AR_TOOL],
        },
        visibility = visibility,
        test_only = test_only,
        labels = ['cc:ld:' + flag for flag in linker_flags] + labels,
        requires = ['go', 'cgo'],
        provides = provides,
        deps = deps,
        exported_deps = exported_deps,
    )

def go_test(name:str, srcs:list, resources:list=None, data:list|dict=None, deps:list=[], worker:str='', visibility:list=None,
            flags:str='', sandbox:bool=None, cgo:bool=False, filter_srcs:bool=True,
            external:bool=False, timeout:int=0, flaky:bool|int=0, test_outputs:list=[],
            labels:list&features&tags=[], size:str=None, static:bool=CONFIG.GO.DEFAULT_STATIC,
            definitions:str|list|dict=None, env:dict=None):
    """Defines a Go test rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      resources (list): Files to embed in the library using //go:embed directives.
      data (list|dict): Runtime data files for the test.
      deps (list): Dependencies
      worker (str): Reference to worker script, A persistent worker process that is used to set up the test.
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      cgo (bool): True if this test depends on a cgo_library.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      external (bool): True if this test is external to the library it's testing, i.e. it uses the
                       feature of Go that allows it to be in the same directory with a _test suffix.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
      env (dict): Additional environment variables to set for the test
    """

    test_package = name + '_lib'
    # Unfortunately we have to recompile this to build the test together with its library.
    lib_rule = go_library(
        name = '_%s#lib' % name,
        srcs = srcs,
        resources = resources,
        package = test_package,
        deps = deps,
        _all_srcs=not external,
        labels = labels,
        test_only = True,
        filter_srcs = filter_srcs,
        _link_extra = False,
        complete = False,
        _generate_import_config=False,
        _generate_pkg_info = False,
        import_path = test_package,
    )

    if cgo:
        archive_name = test_package + "_cgo"
        lib_rule = merge_cgo_obj(
            name = name,
            tag='cgo',
            a_rule = lib_rule,
            visibility = visibility,
            labels = labels + ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)],
            test_only = True,
            deps = deps,
            package = archive_name,
        )
    else:
        archive_name = test_package

    import_config = build_rule(
        name=f'_{name}#lib_import_config',
        cmd = _write_import_config_cmd(archive_name, test_package),
        outs = [f'{test_package}.importconfig'],
        visibility = visibility,
        test_only = True,
        labels = labels,
    )
    main_rule = go_test_main(
        name = name,
        _tag = 'main',
        srcs = srcs,
        deps = deps,
        test_only = True,
        labels = labels,
        test_package = test_package,
        external = external,
    )

    deps += [lib_rule, import_config]
    lib_rule = go_library(
        name='_%s#main_lib' % name,
        srcs = [main_rule],
        deps = deps,
        _needs_transitive_deps = CONFIG.BUILD_CONFIG == "cover" and not CONFIG.GO.COVERAGEREDESIGN,
        test_only = True,
        _generate_import_config = False,
        labels = labels,
        import_path = "main",
        _generate_pkg_info = False,
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, gcov=cgo)

    test_cmd = f'$TEST {flags}'
    if not CONFIG.GO.COVERAGEREDESIGN:
        test_cmd += ' 2>&1 | tee $TMP_DIR/test.results'
    worker_cmd = f'$(worker {worker})' if worker else ""
    if worker_cmd:
        test_cmd = f'{worker_cmd} && {test_cmd} '
        deps += [worker]

    debug_cmd, debug_data, debug_tools = _debug_cmd(
        name = name,
        bin = "./$TEST",
        flags = flags,
        pre_cmd = worker_cmd,
        srcs = srcs + [main_rule],
        deps = deps,
        test_only = True
    )

    if CONFIG.GO.TEST_ROOT_COMPAT:
        # This is a workaround for remote execution; $RESULTS_FILE is set to a relative path remotely.
        test_cmd = f'export TEST=./$(basename $TEST) && mkdir -p $PKG_DIR && mv $TEST $PKG_DIR && cd $PKG_DIR && {test_cmd}'
        for out in test_outputs:
            test_cmd += f' && mv {out} $TMP_DIR/{out}'

    return build_rule(
        name = name,
        srcs = [lib_rule],
        data = data,
        debug_data = debug_data,
        deps = deps,
        outs = [name],
        tools = tools,
        debug_tools = debug_tools,
        cmd = cmds,
        test_cmd = test_cmd,
        debug_cmd = debug_cmd,
        visibility = visibility,
        test_sandbox = sandbox,
        test_timeout = timeout,
        size = size,
        flaky = flaky,
        test_outputs = test_outputs,
        requires = ['go'],
        labels = labels,
        binary = True,
        test = True,
        building_description = "Compiling...",
        needs_transitive_deps = True,
        output_is_complete = True,
        pre_build = _collect_linker_flags(static, definitions),
        env = env,
    )


def go_benchmark(name:str, srcs:list, data:list|dict=None, deps:list=[], visibility:list=None,
                 sandbox:bool=None, cgo:bool=False, filter_srcs:bool=True, external:bool=False, timeout:int=0,
                 labels:list&features&tags=None, static:bool=CONFIG.GO.DEFAULT_STATIC, definitions:str|list|dict=None,
                 test_only=True):
    """Defines a Go test suite that will be run as a benchmark.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      cgo (bool): True if this test depends on a cgo_library.
      filter_srcs (bool): If True, filters source files through Go's standard build constraints.
      external (bool): True if this test is external to the library it's testing, i.e. it uses the
                       feature of Go that allows it to be in the same directory with a _test suffix.
      timeout (int): Timeout in seconds to allow the test to run for.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     Note that it may have negative consequences if the binary contains any cgo
                     (including net/http DNS lookup code potentially).
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
       test_only (bool): If True, is only visible to test rules.
    """
    test_package = name + '_lib'
    # Unfortunately we have to recompile this to build the test together with its library.
    lib_rule = go_library(
        name = '_%s#lib' % name,
        srcs = srcs,
        package = test_package,
        deps = deps,
        _all_srcs=not external,
        labels = labels,
        test_only = True,
        filter_srcs = filter_srcs,
        _link_extra = False,
        complete = False,
        _generate_import_config=False,
        import_path=test_package,
    )
    import_config = build_rule(
        name=f'_{name}#lib_import_config',
        cmd = _write_import_config_cmd(test_package, test_package),
        outs = [f'{test_package}.importconfig'],
        visibility=visibility,
        test_only=True,
        labels=labels,
    )
    if cgo:
        lib_rule = merge_cgo_obj(
            name = name,
            tag = 'cgo',
            a_rule = lib_rule,
            visibility = visibility,
            labels = ['link:plz-out/go/pkg/%s_%s' % (CONFIG.OS, CONFIG.ARCH)] + labels,
            deps = deps,
            test_only = test_only,
        )
    main_rule = go_test_main(
        name = name,
        _tag = 'main',
        srcs = srcs,
        deps = deps,
        benchmark = True,
        test_only = test_only,
        test_package = test_package,
        external = external,
    )
    deps += [lib_rule, import_config]
    lib_rule = go_library(
        name='_%s#main_lib' % name,
        srcs=[main_rule],
        deps=deps,
        _generate_import_config=False,
        labels = labels,
        test_only = test_only,
        import_path="main",
    )
    cmds, tools = _go_binary_cmds(static=static, definitions=definitions, gcov=cgo)

    return build_rule(
        name=name,
        srcs=[lib_rule],
        data=data,
        deps=deps,
        outs=[name],
        tools=tools,
        cmd=cmds,
        visibility=visibility,
        sandbox=sandbox,
        build_timeout=timeout,
        requires=['go', 'test'],
        labels=labels,
        binary=True,
        building_description="Compiling...",
        needs_transitive_deps=True,
        output_is_complete=True,
        test_only=test_only,
        pre_build = _collect_linker_flags(static, definitions),
    )

def go_test_main(name:str, srcs:list, test_package:str="", test_only:bool=False, external=False,
                 deps:list=[], visibility:list=None, _post_build:function=None, _tag=None, benchmark:bool=False,
                 cover:bool=True, labels:list=[]):
    """Outputs the main file for a Go test.

    This essentially does the test discovery and templates out the entry point from it. Note that
    it only generates the main; you will likely need to arrange for compilation of the inputs via
    a separate go_library rule.

    Args:
      name (str): Name of the rule
      srcs (list): Source .go files that define the tests.
      test_package (str): This is the import path of the package to be tested. Defaults to the import path of the current
                    directory.
      test_only (bool): If True, can only be consumed by tests (or other test_only rules).
      deps (list): Any additional dependencies
      visibility (list): Visibility of the rule.
      benchmark (bool): If True, it will run benchmarks instead of tests.
      cover (bool): Indicates whether this library should be considered for coverage annotations.
                    Libraries are only annotated when using `plz cover` (or `plz build -c cover`),
                    but if this is false they never will be. Can be useful for e.g. third-party
                    code that you never want to be instrumented.
      labels (list): Any labels to apply to this rule.
    """
    cover = cover and (CONFIG.BUILD_CONFIG == "cover")
    test_package = test_package or _get_import_path()
    external_flag = "--external" if external else ""
    cmd = f'"$TOOLS_PLZ" testmain --test_package "{test_package}" {external_flag} -o $OUT'
    if benchmark:
        cmd = f'{cmd} --benchmark'
    cmds = {
        'dbg': f'{cmd} $SRCS',
        'opt': f'{cmd} $SRCS',
    }

    if not benchmark:
        cmds['cover'] = f'{cmd} --dir . $SRCS'

    return build_rule(
        name = name,
        tag = _tag,
        srcs = srcs,
        outs = [name + '_main.go'],
        deps = deps,
        cmd = cmds,
        needs_transitive_deps = cover and not CONFIG.GO.COVERAGEREDESIGN,  # Need all dependencies to template coverage variables
        requires = ['go', 'cover_vars'] if cover else ['go'],
        test_only = test_only,
        tools = {
            'plz': [CONFIG.GO.PLEASE_GO_TOOL],
            'go': [CONFIG.GO.GO_TOOL],
        },
        post_build = _post_build,
        visibility = visibility,
        labels = labels,
    )


def cgo_test(name:str, srcs:list, data:list=None, deps:list=None, visibility:list=None,
             flags:str='', sandbox:bool=None, timeout:int=0, flaky:bool|int=0,
             test_outputs:list=None, labels:list&features&tags=None, size:str=None, static:bool=False):
    """Defines a Go test rule over a cgo_library.

    If the library you are testing is a cgo_library, you must use this instead of go_test.
    It's ok to depend on a cgo_library though as long as it's not the same package
    as your test; in that (any any other case of testing a go_library) you must use go_test.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files to compile.
      data (list): Runtime data files for the test.
      deps (list): Dependencies
      visibility (list): Visibility specification
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      static (bool): If True, passes flags to the linker to try to force fully static linking.
                     (specifically `-linkmode external -extldflags static`).
                     Typically this increases size & link time a little but in return the binary
                     has absolutely no external dependencies.
                     It may not be easy to make cgo tests work when linked statically; depending
                     on your toolchain it may not be possible or may fail.
    """
    return go_test(
        name = name,
        srcs = srcs,
        data = data,
        deps = deps,
        cgo = True,
        static = static,
        visibility = visibility,
        flags = flags,
        sandbox = sandbox,
        timeout = timeout,
        flaky = flaky,
        test_outputs = test_outputs,
        labels = labels,
        size = size,
    )


def _remove_redundant_outs(outs):
    """
      Given a list of proposed outputs for this rule (which may be paths to .a
      files or directories), returns outputs that aren't contained within other

      outputs - e.g.:
        remove_redundant_outs(["x/y", "x/z.a", "x/p/q/r", "x/p/q"])
      returns
        ["x/y", "x/z.a", "x/p/q"]
    """
    new_outs = {r: True for r in outs}
    for r in new_outs.keys():
        dirs = r.split("/")
        for i in range(1, len(dirs)):
            root = "/".join(dirs[0:i])
            if new_outs.get(root):
                new_outs[r] = False
    return [r for r in new_outs.keys() if new_outs[r]]


def _go_install_module(name:str, module:str, install:list, src:str, outs:list, deps:list, binary:bool, visibility:list,
                       test_only:bool, licences:list, linker_flags:list, env:dict, build_tags:list, labels:list=[]):
    build_tags = " ".join([f"--build_tag={tag}" for tag in build_tags])

    cc_tool_flag = "--cc_tool=$TOOLS_CC" if CONFIG.GO.CC_TOOL else ''
    cmd = [_set_go_env()]
    if CONFIG.GO.STDLIB:
        deps += _stdlib()
    else:
        cmd += [_generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')]
    cmd += [
        _aggregate_import_cfg_cmd(),
        f"$TOOLS_PLEASE_GO install {build_tags} --trim_path $TMP_DIR --src_root=$(location {src}) --module_name={module} --importcfg=importconfig --go_tool=$TOOLS_GO {cc_tool_flag} --out=pkg/{CONFIG.OS}_{CONFIG.ARCH} " + " ".join(install),
        "cat LD_FLAGS",
    ]

    if binary:
        # This decouples the name of the target from the name of the installed binary when it's unambiguous what the
        # output binary should be. This is especially useful when installing a module like
        # github.com/jstemmer/go-junit-report/v2 which results in a binary called v2 which isn't a very helpful name for
        # a build target.
        bin_name = basename(install[0]) if len(install) == 1 else name
        outs = [f'pkg/{CONFIG.OS}_{CONFIG.ARCH}/bin/{bin_name}']
    else:
        outs = [f'pkg/{CONFIG.OS}_{CONFIG.ARCH}/{out}' for out in _remove_redundant_outs(outs)]

    tools = {
        'go': [CONFIG.GO.GO_TOOL],
        'please_go': [CONFIG.GO.PLEASE_GO_TOOL],
    }
    if CONFIG.GO.CC_TOOL:
        tools["cc"] = [CONFIG.GO.CC_TOOL]

    return build_rule(
        name = name,
        tag = "a_rule" if not binary else None,
        outs = outs,
        deps = deps,
        srcs = [src],
        tools = tools,
        visibility = visibility,
        building_description = 'Compiling...',
        cmd = ' && '.join(cmd),
        binary = binary,
        requires = ['go'],
        test_only = test_only,
        labels = labels + ['link:plz-out/go'] + [f'cc:ld:{f}' for f in linker_flags],
        needs_transitive_deps = True,
        licences = licences,
        post_build = _add_ld_flags,
        env = env,
    )

def _add_ld_flags(name:str, stdout:list):
    stdout = " ".join(stdout)
    if stdout:
        add_label(name, f"cc:ld:{stdout}")


def _module_rule_name(module):
    return module.replace("/", "_")

def go_repo(module: str, version:str=None, download:str=None, name:str=None, install:list=[], requirements:list=[],
        licences=None, patch=None, visibility=["PUBLIC"]):
    """Adds a third party go module to the build graph as a subrepo. This is designed to be closer to how the `go.mod`
    file works, requiring only the module name and version to be specified. Unlike go_module, each package is compiled
    individually, and dependencies between packages are inferred by convention.

    This build definition is designed to replace go_module(), requiring less toil to keep up to date, and improving
    incrementalism and minimalism by compiling each package, rather than the whole module.

    By convention, modules will be registered in subrepos of the same name, replacing forward slashes with
    underscores, e.g. `github.com/stretchr/testify` becomes `github.com_stretchr_testify`. Assuming `go_repo` is
    being used in the standard third party package, `//third_party/go`, the import path
    `github.com/stretchr/testify/assert` is then always resolved to the build label
    `///third_party/go/github.com_stretchr_testify//assert`. Similarly, binary targets are also generated for any "main"
    package, which can be ran with `plz run` or used as tools e.g. to generate protobuf files.

    To avoid cumbersome build labels, you may optionally pass a list of go package wildcards to the install argument of
    this build definition. For example, passing in `name = "testify"`, and `install = ["assert"]`, you may depend on
    `//third_party/go:testify`, instead of the individual packages within, e.g.
    `///third_party/go/github.com_stretchr_testify//assert`

    Args:
      module(str): The name of the module
      version(str): The version of the module to download, if not providing the download parameter
      download(str): A build rule to download the module, usually a go_mod_download().
      name(str): The name of the returned rule. Defaults to the module name with forward slashes replaced with
                 underscores.
      install(list): Optional list of package wildcards to return from this rule. This can be useful to avoid cumbersome
                     labels when depending on this module.
      requirements(list): A list of requirements of this module that are not defined in its go.mod file
      licences(list): The licence of this module to be checked against the allowed licences configured in Please.
      patch(list): Any patch files to apply to the downloaded module.
      visibility(list): The visibility for the returned "install" rule. Doesn't affect the subrepo at all.
    """
    subrepo_name = _module_rule_name(module)
    if install and not name:
        fail("must provide `name` when exposing packages with `install = []`")

    name = name or subrepo_name

    if not version and not download:
        fail("must provide either version or download")

    install_args = " ".join([f"--install={i}" for i in install])

    if not download:
        download = go_mod_download(
            name = tag(name, "dl"),
            module = module,
            version = version,
            licences = licences,
            patch = patch,
        )

    requirements = " ".join(requirements)
    repo = build_rule(
        name = name,
        tag = "repo" if install else None,
        srcs = [download],
        cmd  = f"rm -rf $SRC/.plzconfig && find $SRC -name BUILD -delete && $TOOL generate --src_root=$SRC {install_args} {requirements} && mv $SRC $OUT",
        outs = [subrepo_name],
        tools = [CONFIG.GO.PLEASE_GO_TOOL],
        env= {
            "GOOS": CONFIG.OS,
            "GOARCH": CONFIG.ARCH,
            "CGO_ENABLED": CONFIG.GO.CGO_ENABLED,
        },
        _subrepo = True,
        labels=["go_module_path:" + module],
    )
    subrepo(
        name = subrepo_name,
        dep = repo,
        package_root = f"pkg/{CONFIG.OS}_{CONFIG.ARCH}/{module}",
    )

    if install:
        pkg_name = package_name()
        return filegroup(
            name = name,
            visibility = visibility,
            exported_deps=[f"///{pkg_name}/{subrepo_name}//:installs"],
        )
    else:
        return repo


def go_mod_download(name:str, module:str, version:str, test_only:bool=False, visibility:list=None, strip:list=[],
                    licences:list=None, hashes:list=None, labels:list=[], _tag:str='', deps:list=[],
                    patch:list=[]):
    """Downloads a third-party Go module using `go mod download`

    This rule is typically used in conjunction with go_module() to resolve cyclic dependencies between modules. This rule
    can be passed to go_module() via the download param which enables multiple go_module() rules to compile parts of the
    whole module. It can also be useful to download from a fork of a module where the import path doesn't match the
    repo path.

    Args:
      name (str): Name of the rule
      module (str): The module to download
      version (str): The version of the module.
      deps (list): Dependencies
      visibility (list): Visibility specification
      test_only (bool): If true this rule will only be visible to tests.
      strip (list ): List of paths to strip from the target after downloading but before building it.
      hashes (list): List of hashes to verify the downloaded sources against.
      licences (list): Licences this rule is subject to.
      labels (list): Labels to apply to this rule.
    """
    out = name
    # TODO(jpoole): write a proper please_go tool for this
    cmds = [
        'echo module please_ignore > go.mod', # stops go reading the main go.mod, and downloading all of those too
        'export export GOPATH="$PWD/go_mod_download_folder"', # avoid conflict on "go" folder
        f'$TOOLS_GO mod download -x -modcacherw -json {module}@{version} | tee mod.json',
        'export MOD_DIR=$(cat mod.json | ' 'awk -F\\" \'/"Dir": / { print $4 }\')',
        'export MOD_FILE=$(cat mod.json | ' 'awk -F\\" \'/"GoMod": / { print $4 }\')',
        'cp -r "$MOD_DIR" "$OUT"',
        'rm -rf $OUT/go.mod', # Sometimes this file exists, and sometimes we need to manually copy it in
        'cp -r $MOD_FILE $OUT/go.mod'
    ] + [f'rm -rf "$OUT/{s}"' for s in strip]

    if patch:
        cmds += [f'for p in "$TMP_DIR"/$SRCS_PATCH; do patch -d {out} -p1 < $p; done']

    labels += [f"go_module:{module}@{version}"]

    if CONFIG.GO.REQUIRE_LICENCES and not licences:
        label = canonicalise(f":{name}")
        fail(f"{label} is missing its licence")

    return build_rule(
        name = name,
        srcs = {
            "PATCH": patch,
        },
        tag = _tag,
        outs = [out],
        tools = {
            "go": [CONFIG.GO.GO_TOOL],
        },
        building_description = 'Fetching...',
        cmd = ' && '.join(cmds),
        requires = ['go_src'],
        test_only = test_only,
        labels = labels + [f'dlink:plz-out/go/src/{module}'],
        hashes = hashes,
        sandbox = False,
        licences = licences,
        visibility = visibility,
        deps = deps,
    )

def go_module(name:str='', module:str, version:str='', download:str='', deps:list=[], exported_deps:list=[],
              visibility:list=None, test_only:bool=False, binary:bool=False, install:list=[], labels:list=[],
              hashes:list=None, licences:list=None, linker_flags:list=[], strip:list=[], env:dict={},
              patch:list|str=[], build_tags:list=[]):
    """Defines a dependency on a third-party Go module.

    Note that unlike a normal `go get` call, this does *not* install transitive dependencies.
    You will need to add those as separate rules; `go list -f '{{.Deps}}' <package>` can be
    useful to discover what they should be.

    This rule is different to go_repo() in that it compiles the whole go module in one build action. This can lead to
    issues when modules are cyclically dependent on each other. For this reason, go_repo is recommended over go_module().

    Args:
      name (str): Name of the rule
      module (str): The module to compile
      version (str): The version of the module.
      download (str): Can be provided instead of version to manage downloading the module separately. This must be a
                      rule that has a single output containing the go sources of the module.  Usually this will
                      be a go_mod_download() rule however it doesn't have to be. This can be used for a number of
                      purposes but primarily it is for resolving cyclic dependencies between modules.
      deps (list): Dependencies
      exported_deps (list): Dependencies to make available to anything using this rule.
      visibility (list): Visibility specification
      binary (bool): True if the output of the rule is a binary.
      test_only (bool): If true this rule will only be visible to tests.
      install (list | dict): Only install listed (sub)packages. If the dict form is used, each key should
                             correspond to a target in 'get', with the value defining the list of packages
                             to install for that target. Specify the empty string as an element in the list
                             to install a target's root package.
      strip (list ): List of paths to strip from the target after downloading but before building it.
      labels (list): Additional labels to apply to this rule.
      hashes (list): List of hashes to verify the downloaded sources against.
      licences (list): Licences this rule is subject to.
      linker_flags (list): Any additional linker flags to apply. Linker flags defined in the module itself will
                           automatically be collected so this is typically not necessary.
      env (dict): Any env variables to set during build time. This can be useful to set CGO_CFLAGS etc. to control
                  aspects of compilation.
      build_tags (list): Any build tags to apply to the build context.
    """
    patch = [patch] if isinstance(patch, str) else patch
    if version and download:
        fail("You have provided both version and download. Must provided one or the other.")

    if not download and not version:
        fail("Either version or download should be provided")

    installpkg = install
    install = [f"{module}/{i}" if i != "." and i != "" else module for i in install]

    if not download:
        download = go_mod_download(
            name = name,
            _tag = "get",
            module = module,
            version = version,
            deps = deps,
            test_only = test_only,
            visibility = visibility,
            licences = licences,
            hashes = hashes,
            strip = strip,
            patch = patch,
        )
    outs = []

    # Gets the expected archive name given a target package
    def archive_name(i):
        base = basename(i)
        return f"{i}/{base}.a"
    if not binary:
        if not install:
            outs = [archive_name(module)]
        else:
            for i in install:
                if i == module or i == f"{module}/.":
                    outs += [archive_name(module)]
                elif i == "...":
                    outs += [module]
                elif i.endswith("/..."):
                    outs += [i.removesuffix("/...")]
                else:
                    outs += [archive_name(i)]

    a_rule = _go_install_module(
        name = name,
        module = module,
        install = install or [module],
        binary = binary,
        src = download,
        outs = outs,
        deps = deps + exported_deps,
        test_only = test_only,
        visibility = visibility,
        licences = licences,
        linker_flags = linker_flags,
        env = env,
        build_tags = build_tags,
        labels = labels if binary else [],
    )

    if binary:
        return a_rule

    import_config = build_rule(
        name=name,
        tag='import_config',
        deps = [a_rule],
        visibility = visibility,
        test_only = test_only,
        cmd = _generate_pkg_import_cfg_cmd('"$OUT"', '"$PKG_DIR"', True),
        outs = [f'{name}.importconfig'],
    )

    # Package info rule for the Go packages driver
    pkg_info = _go_pkg_info(
        name = name,
        srcs = [download],
        importconfig = import_config,
        strip = True,
        module = module,
        test_only = test_only,
        install = installpkg,
    )
    exported_deps = exported_deps + [import_config] if exported_deps else [import_config]

    return filegroup(
        name = name,
        srcs = [a_rule],
        deps = deps + [pkg_info],
        exported_deps = exported_deps,
        provides = {
            "go": f":{name}", # provide the filegroup otherwise exported deps don't work
            "go_src": download,
            "pkg_info": pkg_info,
        },
        labels = labels + [f"go_package:{i}" for i in install] + ["go_module_path:" + module],
        visibility = visibility,
        needs_transitive_deps = True,
        test_only = test_only,
        requires = ['go'],
        binary = binary,
    )


def _go_pkg_info(name:str, srcs:list, importconfig:str=None, import_path:str="", package:str="",
                 strip:bool=False, module:str="", complete:bool=False, test_only:bool=False, install:list=[]):
    """Internal-only function for generating the pkg_info files"""
    sflag = '-s "$SRCS_SRCS"' if strip else ''

    install_flags = ""
    for i in install:
        install_flags += f" -p {i}" if i else " -p ."

    if module:
        cmd = f'$TOOL m -m {module} {install_flags}'
    else:
        import_path = _get_import_path(package, import_path)
        cmd = f'$TOOL p -i "{CONFIG.GO.IMPORT_PATH}" -m "{import_path}:$PKG_DIR/{package}.a"'
    return build_rule(
        name = name,
        tag = "pkg_info",
        tools = [CONFIG.GO.PLEASE_GO_TOOL],
        srcs = {
            "srcs": srcs,
            "ic": [importconfig],
        },
        outs = [f"_{name}_pkg_info.json"],
        cmd = f'{cmd} {sflag} > "$OUTS"',
        labels = ["go_pkg_info"],
        test_only = test_only,
    )


def _set_go_env():
    if CONFIG.GO.STDLIB:
        cmd = 'export GOPATH=$TMP_DIR'
    else:
        if CONFIG.HOSTOS == 'freebsd':
            # FreeBSD has some very strange semantics around hardlinks that lead to it finding
            # the wrong thing (essentially os.Executable, which go uses to define GOROOT, returns
            # the most recent hardlink to the file). We can work around this way although it's
            # not very nice (we don't do this globally because OSX doesn't have realpath).
            go_root = f'$(dirname $(dirname $(realpath $TOOLS_GO)))'
        else:
            go_root = '$("$TOOLS_GO" env GOROOT)'
        cmd = f'export GOPATH=$TMP_DIR && export GOROOT={go_root}'

    if CONFIG.GO.C_FLAGS:
        flags = " ".join(CONFIG.GO.C_FLAGS)
        cmd = f'{cmd} && export CFLAGS="{flags}"'
    if CONFIG.GO.LD_FLAGS:
        cmd = f'{cmd} && export LDFLAGS="{CONFIG.GO.LD_FLAGS}"'
    if CONFIG.OS != CONFIG.HOSTOS or CONFIG.ARCH != CONFIG.HOSTARCH:
        cmd = f'{cmd} && export GOOS={CONFIG.OS} && export GOARCH={CONFIG.ARCH}'

    if CONFIG.GO.CGO_ENABLED:
        return f'export CGO_ENABLED={CONFIG.GO.CGO_ENABLED} && {cmd}'

    return cmd


def _go_library_cmds(import_path:str="", complete=True, all_srcs=False, cover=True, filter_srcs=True, abi=False, embedcfg=None):
    """Returns the commands to run for building a Go library."""
    filter_cmd = 'export SRCS_GO="$(\"${TOOLS_PLEASE_GO}\" filter ${SRCS_GO})"; ' if filter_srcs else ''
    # Invokes the Go compiler.
    complete_flag = '-complete ' if complete else ''
    embed_flag = ' -embedcfg $SRCS_EMBED' if embedcfg else ''
    out_cmd = ' -o "$OUTS_O" -symabis $SRCS_ABI -asmhdr "$OUTS_H"' if abi else ' -o "$OUT"'
    compile_cmd = f'"$TOOLS_GO" tool compile -importcfg importconfig -trimpath "$TMP_DIR" {complete_flag}{embed_flag} -pack {out_cmd}'
    package_flag = f" -p {import_path}" if import_path else ""
    if CONFIG.GO.RACE:
        compile_cmd += ' -race'

    gen_import_cfg = _set_go_env()
    if not CONFIG.GO.STDLIB:
        gen_import_cfg += ' && ' + _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')
    gen_import_cfg += ' && ' + _aggregate_import_cfg_cmd()
    prefix = ('export SRCS_GO="$PKG_DIR/*.go"; ' + gen_import_cfg) if all_srcs else gen_import_cfg

    cmds = {
        'dbg': f'{prefix}; {filter_cmd}{compile_cmd}{package_flag} -N -l $SRCS_GO',
        'opt': f'{prefix}; {filter_cmd}{compile_cmd}{package_flag} $SRCS_GO',
    }
    if cover:
        if CONFIG.GO.COVERAGEREDESIGN:
            cmds['cover'] = f'{prefix}; {filter_cmd} $TOOLS_PLEASE_GO cover -c covcfg.json -o covfiles.txt -g $TOOLS_GO {package_flag} $SRCS_GO && {compile_cmd} -coveragecfg covcfg.json {package_flag} `cat covfiles.txt`'
        else:
            cover_cmd = 'for SRC in $SRCS_GO; do BN=$(basename $SRC); "$TOOLS_GO" tool cover -mode=set -var=GoCover_${BN//[.-]/_} $SRC > _tmp.go && mv -f _tmp.go $SRC; done'
            cmds['cover'] = f'{prefix}; {filter_cmd}{cover_cmd} && {compile_cmd}{package_flag} $SRCS_GO'
    return cmds


def _go_binary_cmds(static=False, ldflags='', pkg_config='', definitions=None, gcov=False, split_debug=False):
    """Returns the commands to run for linking a Go binary."""

    _link_cmd = f'"$TOOLS_GO" tool link -importcfg importconfig -tmpdir "$TMP_DIR" -extld "$TOOLS_LD" -o "$OUT"'

    gen_import_cfg = _set_go_env()
    if not CONFIG.GO.STDLIB:
        gen_import_cfg += ' && ' + _generate_pkg_import_cfg_cmd("goroot.importconfig", '"$GOROOT"')
    gen_import_cfg += ' && ' + _aggregate_import_cfg_cmd()

    linkerdefs = []
    if definitions is None:
        pass
    elif isinstance(definitions, str):
        linkerdefs += [f'{definitions}']
    elif isinstance(definitions, list):
        linkerdefs += [f'{linkerdef}' for linkerdef in definitions]
    elif isinstance(definitions, dict):
        linkerdefs = [k if v is None else f'{k}={v}' for k, v in sorted(definitions.items())]

    defs = ' '.join([f'-X "{linkerdef}"' for linkerdef in linkerdefs])

    if static:
        flags = f'-linkmode external -extldflags "-static {ldflags} {pkg_config}"'
    elif ldflags or pkg_config:
        flags = f'-extldflags "{ldflags} {pkg_config}"'
    else:
        flags = ''

    if len(defs) > 0:
        flags += " " + defs

    if CONFIG.GO.BUILDMODE:
        flags += f" -buildmode {CONFIG.GO.BUILDMODE}"
    if CONFIG.GO.RACE:
        flags += " -race"

    if split_debug:
        return f'{gen_import_cfg} && {_link_cmd} {flags} $SRCS && $TOOLS_STRIP -o $OUT -f $OUT.sym $OUT', {
            'go': [CONFIG.GO.GO_TOOL],
            'ld': [CONFIG.GO.CC_TOOL],
            'strip': [CONFIG.GO.STRIP_TOOL],
        }

    cmds = {
        'dbg': f'{gen_import_cfg} && {_link_cmd} {flags} $SRCS',
        'opt': f'{gen_import_cfg} && {_link_cmd} {flags} -s -w $SRCS',
    }
    if gcov and CONFIG.GO.CPP_COVERAGE:
        cmds['cover'] = f'{gen_import_cfg} && {_link_cmd} {flags} -extldflags="-lgcov" $SRCS'

    return cmds, {
        'go': [CONFIG.GO.GO_TOOL],
        'ld': [CONFIG.GO.CC_TOOL],
    }


def _go_import_path_cmd(import_path):
    """Returns a partial command which is used for setting up the Go import path."""
    if not import_path:
        return ''
    elif import_path.startswith('/'):
        fail('GO_IMPORT_PATH cannot start with a /')
    elif '/' in import_path:
        return ' && mkdir -p %s && ln -s "$TMP_DIR" %s' % (dirname(import_path), import_path)
    else:
        return ' && ln -s "$TMP_DIR" ' + import_path


def _collect_linker_flags(static, definitions):
    """Returns a pre-build function to apply transitive linker flags to a go_binary rule."""
    def collect_linker_flags(name):
        ldflags, pkg_config = _get_ldflags_and_pkgconfig(name)
        if ldflags or pkg_config:
            cmds, _ =  _go_binary_cmds(static=static, ldflags=ldflags, pkg_config=pkg_config, definitions=definitions)
            for k, v in cmds.items():
                set_command(name, k, v)
    return collect_linker_flags


def _get_ldflags_and_pkgconfig(name):
    """Returns the ldflags and pkg-config invocations for a target."""
    labels = get_labels(name, 'cc:')
    ldflags = ' '.join([l[3:] for l in labels if l.startswith('ld:')])
    pkg_config = ' '.join([l[3:] for l in labels if l.startswith('pc:')])
    return (ldflags, f'`pkg-config --libs {pkg_config}`') if pkg_config else (ldflags, '')


# `dlv` is currently the only debugger supported.
def _debug_cmd(name:str, bin:str, flags:str='', pre_cmd:str='', srcs:list=[], deps:list=[], test_only:bool=False):
    if CONFIG.BUILD_CONFIG != 'dbg':
        return "", None, None

    # Delve command.
    cmd = f"$DEBUG_TOOLS_DLV exec {bin} --check-go-version=false"
    if CONFIG.DEBUG_PORT:
        cmd = f"{cmd} --headless=true --listen=localhost:{CONFIG.DEBUG_PORT} --api-version=2"
    cmd = f"{cmd} -- {flags}"

    tools = {
        'dlv': CONFIG.GO.DELVE_TOOL
    }

    # Make sources available to the debugger.
    debug_srcs_tar = f".{name}_debug_srcs.tar"
    data = [
        build_rule(
            name = name,
            tag = "debug_srcs",
            srcs = srcs,
            # Archive all sources.
            cmd = f"find . -name \"*.go\" | tar -cf {debug_srcs_tar} -T -",
            outs = [debug_srcs_tar],
            deps = deps,
            test_only = test_only,
            requires = ["go_src"],
            needs_transitive_deps = True,
        )
    ]
    cmd = f"tar -xf $PKG_DIR/{debug_srcs_tar} && {cmd}"

    if pre_cmd:
        cmd = f"{pre_cmd} && {cmd}"

    return cmd, data, tools


def _stdlib():
    """Returns a dependency for the Go stdlib.

    This is a bit fiddly since we need to work around Please making the value in the config
    absolute (which we don't expect) but also handling `go_get`.
    """
    stdlib = CONFIG.GO.STDLIB
    if CONFIG.OS != CONFIG.HOSTOS or CONFIG.ARCH != CONFIG.HOSTARCH:
        if stdlib.startswith('/////'):
            stdlib = stdlib.removeprefix('///')
        stdlib = f'///{CONFIG.OS}_{CONFIG.ARCH}{stdlib}'
    return [stdlib]
